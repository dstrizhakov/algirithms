![Оригигальный репозиторий RSschool](https://github.com/rolling-scopes-school/tasks/blob/master/tasks/materials/algorithms.md)

## Базовые алгоритмы сортировки и поиска

### Big-О или «О» большое
В программировании Big-О показывает, за сколько шагов (тактов процессора) выполняется алгоритм.\
Характеризует быстродействие функции (эффективность конкретного алгоритма).\
Использовать Big-О для оценки сложности алгоритма предложил Дональд Кнут.\
Читаем: О(1) – О от одного, О(n) – О от n.

Чем быстрее возрастает время выполнения функции при увеличении количества элементов, тем менее эффективен алгоритм. Одними из самых часто встречаемых сложностей являются:

- О(1)
- O(log n)
- O(n)
- O(n log n)
- O(n²)
- O(n!)

Их эффективность:

![Наглядная сложность выполнения алгоритмов](images/big-o.png)

Следующее демо позволяет наглядно сравнить скорость выполнения некоторых алгоритмов сортировки, отличающихся значением Big-О (картинка кликабельна).

[![Demo images](images/algoritms-timer-demo.png)](https://algorithms-timer-demo.netlify.app/)

### Пузырьковая сортировка
- Пробегает набор данных слева направо, сравнивая значения внутри каждой пары и перемещая наименьшее влево.
  Процесс повторяется до тех пор, пока ни одно значение уже не может быть перемещено.
- Алгоритм очень прост в реализации, но малоэффективен
- Эффективность («О» большое):
  - Наилучший вариант: O(n).
  - Средний и худший варианты: O(n²).

**Пузырьковая сортировка**

```js
function bubbleSort(arr) {
  const n = arr.length;
  for (let i = 0; i < n - 1; i++) {
    for (let j = 0; j < n - 1 - i; j++) {
      if (arr[j + 1] < arr[j]) {
        let t = arr[j + 1];
        arr[j + 1] = arr[j];
        arr[j] = t;
      }
    }
  }
  return arr;
}
bubbleSort(arr);
```

### Сортировка слиянием (merge sort)
- Весь набор данных делится минимум на две группы.
  Пары значений сравниваются между собой, наименьшее перемещается влево.
  После сортировки внутри всех пар, сравниваются левые значения двух левых пар. Таким образом, создаётся группа из четырёх значений: два наименьшие — слева, наибольшие — справа.
  Процесс повторяется до тех пор, пока не останется только один набор.
- Это один из фундаментальных алгоритмов сортировки.
- Эффективность («О» большое):
  - Наилучший вариант: O(n).
  - Средний и худший варианты: O(n log n).

### Быстрая сортировка
- Весь набор данных делится пополам путём выбора среднего элемента и перемещения всех, кто меньше него, влево.
  Затем такая же процедура итерационно выполняется с левой частью до тех пор, пока не останутся только два элемента. В результате левая часть окажется отсортированной.
  Затем всё то же самое делается с правой частью.

Хотя «О» большое здесь имеет те же значения (а в ряде случаев — хуже), что и у многих других алгоритмов сортировки, но на практике этот алгоритм зачастую работает быстрее, например, той же сортировки слиянием.
Данные будут последовательно делиться пополам, пока не будут целиком отсортированы.

- Эффективность («О» большое):
  - Наилучший вариант: O(n).
  - Средний вариант: O(n log n).
  - Худший вариант: O(n²).

**Сравнение алгоритмов сортировки слиянием и быстрой сортировки**

Быстрая сортировка на практике зачастую эффективнее.
Сортировка слиянием сразу делит набор данных на наименьшие возможные группы, а затем восстанавливает набор, инкрементально сортируя и укрупняя группы.
Быстрая сортировка последовательно делит набор по среднему значению, пока он не будет отсортирован рекурсивно.

**Быстрая сортировка**
```js
function quickSort(arr) {
  if (arr.length == 0) return [];
  let a = [],
    b = [],
    p = arr[0];

  for (let i = 1; i < arr.length; i++) {
    if (arr[i] < p) a.push(arr[i]);
    else b.push(arr[i]);
  }
  return quickSort(a).concat(p, quickSort(b));
}
quickSort(arr);
```

### Бинарный поиск

[Что такое бинарный поиск](https://youtu.be/9EmO9_MK1gQ?t=34)

**Бинарный поиск**
```js

const arr = [-1, 0, 1, 2, 3, 4, 6, 100, 10000];

function binarySearchIterationMethod(arr, i) {
  let left = 0;
  let right = arr.length - 1;
  let mid;

  while (left <= right) {
    mid = Math.floor((right + left) / 2);

    if (arr[mid] === i) {
      return mid;
    } else if (arr[mid] > i) {
      right = mid - 1;
    } else {
      left = mid + 1;
    }
  }

  return -1;
}

binarySearchIterationMethod(arr, 100); // 7

function binarySearchRecursiveMethod(arr, i, left = 0, right = arr.length - 1) {
  if (left > right) return -1;
  else {
    let mid = Math.floor((right + left) / 2);
    if (arr[mid] === i) {
      return mid;
    } else if (arr[mid] > i) {
      return binarySearchRecursiveMethod(arr, i, left, mid - 1);
    } else {
      return binarySearchRecursiveMethod(arr, i, mid + 1, right);
    }
  }
}

binarySearchRecursiveMethod(arr, 5); // -1

```
